class Solution {
    /**
     * Inserts a new node with value x after the middle node of the list.
     *
     * Problem Interpretation:
     * - If list has odd length → insert after the exact middle node.
     * - If list has even length → insert after the first middle node.
     *
     * Example:
     * 1 -> 2 -> 4 and x =3
     * Middle = 2
     * Result: 1 -> 2 -> 3 -> 4
     *
     * 10 -> 20 -> 40 -> 50 and x = 30
     * First middle = 20
     * Result: 10 -> 20 -> 30 -> 40 -> 50
     *
     * Approach:
     * - Use slow and fast pointers to find middle.
     * - For odd length: slow will point to middle.
     * - For even length: slowPrev will point to first middle.
     * - Insert new node after appropriate middle node.
     */
    public Node insertInMiddle(Node head, int x) {
        // Edge case: empty list
        if (head == null) {
            return new Node(x);
        }

        Node middleNode = getMiddleNode(head);

        Node node = new Node(x);

        // Insert after middle
        node.next = middleNode.next;
        middleNode.next = node;

        return head;
    }

    /**
     * Returns the node after which new element should be inserted.
     *
     * - For odd length → returns exact middle.
     * - For even length → returns first middle.
     */
    private Node getMiddleNode(Node head) {
        Node slow = head;
        Node fast = head;
        Node slowPrev = null;

        while (fast != null && fast.next != null) {
            slowPrev = slow;
            slow = slow.next;
            fast = fast.next.next;
        }

        // Odd length list (fast not null)
        if (fast != null) {
            return slow;
        }

        // Even length list
        return slowPrev;
    }
}
