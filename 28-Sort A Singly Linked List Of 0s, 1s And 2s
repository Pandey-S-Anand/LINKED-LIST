//Bruteforce Approach

class Solution {
    static Node segregate(Node head) {
        // Initialize currentNode to traverse the linked list
        Node currentNode = head;
        
        // Counters for number of 0s, 1s, and 2s in the list
        int count0 = 0, count1 = 0, count2 = 0;

        // First traversal: count the occurrences of 0, 1 and 2
        while (currentNode != null) {
            int value = currentNode.data;

            if (value == 0) {
                count0++;
            } else if (value == 1) {
                count1++;
            } else {
                count2++;
            }

            // Move to the next node
            currentNode = currentNode.next;
        }

        // Reset currentNode to the head of the list for second traversal
        currentNode = head;

        // Second traversal: overwrite node data with 0s, count0 times
        while (count0-- > 0) {
            currentNode.data = 0;
            currentNode = currentNode.next;
        }

        // Continue overwriting with 1s, count1 times
        while (count1-- > 0) {
            currentNode.data = 1;
            currentNode = currentNode.next;
        }

        // Finally, overwrite with 2s, count2 times
        while (count2-- > 0) {
            currentNode.data = 2;
            currentNode = currentNode.next;
        }

        // Return the head of the sorted linked list
        return head;
    }
}



//Optimal Approach

class Solution {
    // Head and tail pointers for each group
    private Node zeroHead, oneHead, twoHead;
    private Node zeroTail, oneTail, twoTail;

    Node segregate(Node head) {
        Node currentNode = head;

        // Step 1: Traverse and divide nodes into corresponding groups
        while (currentNode != null) {
            int value = currentNode.data;

            if (value == 0) {
                append(currentNode, 0);
            } else if (value == 1) {
                append(currentNode, 1);
            } else {
                append(currentNode, 2);
            }

            currentNode = currentNode.next;
        }

        // Step 2: Prevent cycles by terminating the current group tails
        if (zeroTail != null) {
            zeroTail.next = null;
        }
        if (oneTail != null) {
            oneTail.next = null;
        }
        if (twoTail != null) {
            twoTail.next = null;
        }

        // Step 3: Connect the separated groups and return the new head
        return connectGroups();
    }

    private void append(Node node, int group) {
        if (group == 0) {
            if (zeroHead == null) {
                zeroHead = zeroTail = node;
            } else {
                zeroTail.next = node;
                zeroTail = node;
            }
        } else if (group == 1) {
            if (oneHead == null) {
                oneHead = oneTail = node;
            } else {
                oneTail.next = node;
                oneTail = node;
            }
        } else { // group == 2
            if (twoHead == null) {
                twoHead = twoTail = node;
            } else {
                twoTail.next = node;
                twoTail = node;
            }
        }
    }

    private Node connectGroups() {
        // Case 1: 0s are present
        if (zeroTail != null) {
            if (oneHead == null && twoHead == null) {
                return zeroHead; // Only 0s present
            }

            if (oneHead != null && twoHead != null) { // 0s, 1s, and 2s present
                zeroTail.next = oneHead;
                oneTail.next = twoHead;
            } else if (oneHead == null) { // 0s and 2s present
                zeroTail.next = twoHead;
            } else { // 0s and 1s present
                zeroTail.next = oneHead;
            }

            return zeroHead;
        }

        // Case 2: 0s absent, 1s are present
        if (oneTail != null) {
            if (twoHead != null) { // 1s and 2s present
                oneTail.next = twoHead;
            }
            return oneHead; // Only 1s present
        }

        // Case 3: Only 2s present
        if (twoTail != null) {
            return twoHead;
        }

        // Case 4: Empty list (head was null)
        return null;
    }
}
