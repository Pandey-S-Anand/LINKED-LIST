//Bruteforce Approach

class Solution {
    /**
     * Important Limitation:
     * - This does NOT rearrange nodes.
     * - It only modifies node values.
     *
     * If node identity matters, this approach is not ideal.
     */
    public Node segregate(Node head) {
        if (head == null || head.next == null) {
            return head;
        }
        
        //Counts the frequency of 0s, 1s, and 2s.
        int[] counts = countFrequencies(head);
        
        //Overwrites node values based on computed counts.
        overwriteValues(head, counts);

        return head;
    }

    private int[] countFrequencies(Node head) {
        int count0 = 0;
        int count1 = 0;
        int count2 = 0;

        Node node = head;

        while (node != null) {
            if (node.data == 0) {
                count0++;
            } else if (node.data == 1) {
                count1++;
            } else {
                count2++;
            }
            node = node.next;
        }

        return new int[]{count0, count1, count2};
    }

    private void overwriteValues(Node head, int[] counts) {
        int count0 = counts[0];
        int count1 = counts[1];
        int count2 = counts[2];

        Node node = head;

        while (node != null) {
            if (count0 > 0) {
                node.data = 0;
                count0--;
            } else if (count1 > 0) {
                node.data = 1;
                count1--;
            } else {
                node.data = 2;
                count2--;
            }

            node = node.next;
        }
    }
}


//Optimal Approach

class Solution {
    public Node segregate(Node head) {
        // Base case: empty list or single node list
        if (head == null || head.next == null) {
            return head;
        }

        // Dummy heads for three separate lists
        Node headZero = new Node(-1); // Dummy node for 0s list
        Node tailZero = headZero; // Tail pointer for 0s list

        Node headOne = new Node(-1); // Dummy node for 1s list
        Node tailOne = headOne; // Tail pointer for 1s list

        Node headTwo = new Node(-1); // Dummy node for 2s list
        Node tailTwo = headTwo; // Tail pointer for 2s list

        Node node = head;

        /**
         * Traverse the original list once.
         * Detach each node and append it
         * to the appropriate sub-list.
         */
        while (node != null) {

            if (node.data == 0) {
                // Append node to 0s list
                tailZero.next = node;
                tailZero = tailZero.next;
            } else if (node.data == 1) {
                // Append node to 1s list
                tailOne.next = node;
                tailOne = tailOne.next;
            } else {
                // Append node to 2s list
                tailTwo.next = node;
                tailTwo = tailTwo.next;
            }

            // Store next reference before detaching
            Node next = node.next;

            // Break original linkage to avoid accidental cycles
            node.next = null;

            // Move forward
            node = next;
        }

        // connect the three lists.
        return connectGroups(headZero.next, tailZero, headOne.next, tailOne, headTwo.next, tailTwo);
    }

    /**
    * Connects the three segregated lists in order:
    *
    *      0s → 1s → 2s
    *
    * IMPORTANT:
    * The final head of the merged list will be:
    *
    * - headZero if 0s list exists
    * - else headOne if 1s list exists
    * - else headTwo
    *
    * Why?
    * Because we must preserve sorted order:
    * All 0s should appear first, then 1s, then 2s.
    *
    * So the first non-empty group becomes the final head.
    */
    private Node connectGroups(Node headZero, Node tailZero, Node headOne, Node tailOne, Node headTwo, Node tailTwo) {
        // 0s list exists
        if (headZero != null) {
            if (headOne != null) {
                // 0s → 1s
                tailZero.next = headOne;

                if (headTwo != null) {
                    // 1s → 2s
                    tailOne.next = headTwo;
                }

            } else if (headTwo != null) {
                // 0s → 2s (no 1s present)
                tailZero.next = headTwo;
            }

            return headZero;
        }

        // No 0s, but 1s exist
        if (headOne != null) {
            if (headTwo != null) {
                // 1s → 2s
                tailOne.next = headTwo;
            }

            return headOne;
        }

        //Only 2s exist
        if (headTwo != null) {
            return headTwo;
        }

        // Should not be reached if input constraints guarantee 0/1/2 values
        return null;
    }
}
