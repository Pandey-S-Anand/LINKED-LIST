//Bruteforce Approach

class Solution {
    /**     
     * Approach (HashMap based detection):
     * - Traverse the linked list while storing each visited node
     *   along with the step number at which it was first seen.
     * - If we encounter a node that already exists in the map,
     *   it means a cycle is detected.
     * - The length of the cycle is:
     *      currentStep - firstSeenStepOfThatNode
     *
     * Why this works:
     * - When we revisit the same node reference,
     *   we must have completed one full cycle.
     *
     * Note:
     * - If no cycle exists, return 0.
     */
    public int lengthOfLoop(Node head) {
        Map<Node, Integer> visitedStepMap = new HashMap<>();
        Node node = head;
        int step = 1;

        while (node != null) {
            // If node already seen → cycle detected
            if (visitedStepMap.containsKey(node)) {
                return step - visitedStepMap.get(node);
            }

            // Store node reference with step number
            visitedStepMap.put(node, step++);

            node = node.next;
        }

        // No cycle present
        return 0;
    }
}


//Optimal Approach

class Solution {
    public int lengthOfLoop(Node head) {
        Node slow = head;
        Node fast = head;

        // Step 1: Detect cycle using fast and slow pointers
        while (fast != null && fast.next != null) {
            slow = slow.next;           // move 1 step
            fast = fast.next.next;      // move 2 steps

            // If they meet → cycle exists
            if (slow == fast) {
                return findLoopLength(slow);
            }
        }

        // No cycle
        return 0;
    }

    /**
     * Calculates the length of the loop.
     *
     * Logic:
     * - When slow and fast meet, they meet somewhere inside the cycle.
     * - From that meeting point, we traverse the cycle
     *   until we come back to the same node.
     * - Count how many steps it takes.
     *
     * Why this works:
     * - In a cycle, every node is reachable again.
     * - Starting from any node inside the loop,
     *   one full traversal brings us back to the same node.
     */
    private int findLoopLength(Node meetingPoint) {
        Node node = meetingPoint.next; // Start from the next node (clockwise next) where the cycle was detected (fast.next)
        int length = 1; // Count for the node where the cycle was detected i.e meetingPoint

        // Traverse until we come back to meetingPoint
        while (node != meetingPoint) {
            node = node.next;
            length++;
        }

        return length;
    }
}
