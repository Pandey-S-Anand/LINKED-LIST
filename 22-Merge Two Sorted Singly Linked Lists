/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

//Verbose implementation

class Solution {
    public ListNode mergeTwoLists(ListNode head1, ListNode head2) {
        ListNode mergedHead = null; // Head of merged list
        ListNode mergedTail = null; // Tail pointer for efficient append

        ListNode node1 = head1; // Traverses first list
        ListNode node2 = head2; // Traverses second list

        // Merge while both lists have nodes
        while (node1 != null && node2 != null) {
            if (node1.val <= node2.val) {
                // Save next reference before detaching
                ListNode next = node1.next;

                // First insertion case
                if (mergedHead == null) {
                    mergedHead = mergedTail = node1;
                } else {
                    // Append to merged list
                    mergedTail.next = node1;
                    mergedTail = node1;
                }

                node1.next = null; // Detach from original list
                node1 = next; // Move forward in list1
            } else {
                ListNode next = node2.next;

                if (mergedHead == null) {
                    mergedHead = mergedTail = node2;
                } else {
                    mergedTail.next = node2;
                    mergedTail = node2;
                }

                node2.next = null;
                node2 = next;
            }
        }

        // Append remaining nodes from list1 (if any)
        if (node1 != null) {
            if (mergedHead == null) {
                mergedHead = mergedTail = node1;
            } else {
                mergedTail.next = node1;
            }
        }

        // Append remaining nodes from list2 (if any)
        if (node2 != null) {
            if (mergedHead == null) {
                mergedHead = mergedTail = node2;
            } else {
                mergedTail.next = node2;
            }
        }

        return mergedHead;
    }
}


//Optimal implementation

class Solution {
    public ListNode mergeTwoLists(ListNode head1, ListNode head2) {

        // Dummy node to avoid handling special case for first insertion
        ListNode mergedHead = new ListNode(-1);

        // Tail pointer to build merged list
        ListNode mergedTail = mergedHead;

        // Pointers to traverse both input lists
        ListNode node1 = head1;
        ListNode node2 = head2;

        // Traverse both lists until one becomes null
        while (node1 != null && node2 != null) {
            if (node1.val <= node2.val) {
                // Save next reference before detaching
                ListNode next = node1.next;
                // Detach node1 from its original list (optional safety)
                node1.next = null;
                // Attach node1 to merged list
                mergedTail.next = node1;
                // Move node1 forward
                node1 = next;

            } else {
                ListNode next = node2.next;
                node2.next = null;
                mergedTail.next = node2;
                node2 = next;
            }

            // Move mergedTail forward after attachment
            mergedTail = mergedTail.next;
        }

        // Attach remaining nodes from list1 (if any)
        if (node1 != null) {
            mergedTail.next = node1;
        }

        // Attach remaining nodes from list2 (if any)
        if (node2 != null) {
            mergedTail.next = node2;
        }

        // Skip dummy node and return actual head
        return mergedHead.next;
    }
}
