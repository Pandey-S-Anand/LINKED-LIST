/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    /**
     *
     * Important Constraints from the Problem:
     * 1) The node to be deleted is NOT the last node.
     * 2) All node values are distinct.
     *
     * Why can't the node be the last node?
     * --------------------------------------
     * We are NOT given the head of the list.
     * The only way to "delete" a node in this problem is by:
     *   - Continuously copying the value of the next node into the current node
     *     until we reach the last node,
     *   - While keeping track of the previous node,
     *   - And finally unlinking the last node by setting prevNode.next = null.
     *
     * If the given node is the last node:
     *   - node.next would be null.
     *   - There would be no next value to copy.
     *   - Hence, deletion would be impossible without access to the head.
     *
     *
     * Why does the problem say values are distinct?
     * ---------------------------------------------
     * Having distinct values ensures clarity when verifying the output
     * and avoids confusion during explanation or debugging.
     *
     * Example:
     * 1 -> 2 -> 3 -> 5 -> 2 -> 6
     *
     * Suppose we are asked to delete the second last node with value 2.
     * Even after deletion, there would still be another node with value 2
     * (the second node in the list).
     *
     * This could lead to ambiguity while verifying whether the correct
     * node was deleted, since values are not unique.
     */
    public void deleteNode(ListNode node) {
        ListNode prevNode = null;

        // Shift values forward
        while (node.next != null) {
            node.val = node.next.val;
            prevNode = node;
            node = node.next;
        }

        // Unlink the final node
        prevNode.next = null;
    }
}


/*
 * Consider the linked list: 1 -> 2 -> 3 -> 4 -> 5
 *
 * Suppose we want to delete the node with value 2, and we are only given a reference to that node.
 *
 * 1. We perform `node.val = node.next.val`, which copies the value of the next node (3) into the current node (2).
 *    The list now looks like: 1 -> 3 -> 3 -> 4 -> 5
 *
 * 2. Then we update `node.next = node.next.next`, which bypasses the next node (original 3) and points to node 4.
 *    The list becomes: 1 -> 3 -> 4 -> 5
 *
 * 3. The original node with value 3 is no longer referenced in the list and becomes eligible for garbage collection.
 *
 * Final result: the node with value 2 is effectively deleted by copying over the next nodeâ€™s value and skipping it.
 */

//Optimal Approach

class Solution {
    public void deleteNode(ListNode node) {
        node.val = node.next.val;
        node.next = node.next.next;
    }
}
