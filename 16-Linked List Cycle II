//Bruteforce approach

public class Solution {
    /**
     * Returns the node where the cycle begins in a linked list.
     * If no cycle exists, returns null.
     *
     * Approach (HashSet based detection):
     * - Traverse the list while storing each visited node reference.
     * - If a node is encountered that already exists in the set,
     *   that node is the start of the cycle.
     *
     * Important:
     * - We compare node references, NOT node values.
     * - Multiple nodes may have the same value,
     *   but cycle detection must be reference-based.
     */
    public ListNode detectCycle(ListNode head) {
        Set<ListNode> seenNodes = new HashSet<>();
        ListNode node = head;

        while (node != null) {
            // If node already visited → cycle entry found
            if (seenNodes.contains(node)) {
                return node;
            }

            seenNodes.add(node);
            node = node.next;
        }

        // No cycle detected
        return null;
    }
}


//Optimal approach

public class Solution {
    public ListNode detectCycle(ListNode head) {
        // Edge case: empty list or single node without cycle
        if (head == null || head.next == null) {
            return null;
        }
        // Detect meeting point inside the cycle (if any)
        ListNode meetingPoint = getMeetingPoint(head);

        // If no meeting point found → no cycle
        if (meetingPoint == null) {
            return null;
        }
        //Find and return the starting node of the cycle
        return getCycleStart(meetingPoint, head);
    }

    private ListNode getMeetingPoint(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;

        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            // If both pointers meet → cycle detected
            if (slow == fast) {
                return slow;
            }
        }
        // No cycle
        return null;
    }

    /*
    * Example of Floyd's Cycle Detection (Tortoise and Hare):
    *
    * Linked list structure with cycle:
    * A -> B -> C -> D -> E
    *           ^         |
    *           |         v
    *           H <- G <- F
    *
    * - They meet at node G (index 6), confirming a cycle exists.
    * - This meeting point is not necessarily the cycle's start.
    *
    * The `getCycleStart` method works because of the following reasoning:
    *
    *   Distances:
    * - L = distance from head to start of cycle = 2 (A → B → C)
    * - X = distance from start of cycle (C) to meeting point (G) = 4 (C → D → E → F → G)
    * - C = total cycle length = 6 (C → D → E → F → G → H → C)
    *
    * Step 2: Key Distance Relationship
    * - When the pointers meet at the meeting point (M), the distances traveled are:
    *   - `slow`: L + X
    *   - `fast`: L + X + k * C (where k is the number of full loops by `fast`).
    * - Since `fast` moves twice as fast as `slow`:
    *   2(L + X) = L + X + k * C
    *   => L + X = k * C
    * - This implies that the distance from the head to the start of the cycle (L)
    *   is equal to the distance from the meeting point to the start of the cycle (C - X). (i.e H -> C)
    *
    * Step 3: Resetting and Moving Pointers
    * - One pointer (`slow`) is reset to the head.
    * - The other pointer (`fast`) remains at the meeting point (M).
    * - Both pointers move one step at a time.
    * - After L steps from the head and (C - X) steps from the meeting point,
    *   both pointers will meet at the start of the cycle.
    *
    * This ensures that the algorithm correctly identifies the start of the cycle.
    */
    private ListNode getCycleStart(ListNode meetingPoint, ListNode head) {
        ListNode pointer1 = head;
        ListNode pointer2 = meetingPoint;

        // Move both pointers at same speed
        while (pointer1 != pointer2) {
            pointer1 = pointer1.next;
            pointer2 = pointer2.next;
        }

        return pointer1; // Start of the cycle (pointer1 or pointer2)
    }
}
