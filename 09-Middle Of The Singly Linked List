/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {

    /**
     * Returns the middle node of a singly linked list.
     *
     * 1) First, calculate the total length of the list.
     * 2) Compute middle index as length / 2.
     *    - For odd length: returns the exact middle.
     *    - For even length: returns the second middle (as per problem requirement).
     * 3) Traverse again up to middle index and return that node.
     *
     * Example:
     * 1 -> 2 -> 3 -> 4 -> 5
     * length = 5 → middleIdx = 5/2 = 2 → return node at index 2 (0-based) → 3
     *
     * 1 -> 2 -> 3 -> 4 -> 5 -> 6
     * length = 6 → middleIdx = 6/2 = 3 → return node at index 3 → 4
     *
     */
    public ListNode middleNode(ListNode head) {
        // Computes the length of the linked list.
        int length = getLength(head);

        // For even length, this automatically gives second middle
        int middleIdx = length / 2;

        ListNode node = head;

        // Move middleIdx steps forward
        while (middleIdx != 0) {
            node = node.next;
            middleIdx--;
        }

        return node;
    }

    private int getLength(ListNode head) {
        int length = 0;
        ListNode node = head;

        while (node != null) {
            length++;
            node = node.next;
        }

        return length;
    }
}


//Optimal Approach

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    /**
     * The logic of the slow and fast pointer approach is based on the following analogy:
     * 
     * - Imagine a person A (moving at speed X jumps/hour) wants to find the middle of a track.
     * - The track's total length (L km) is unknown to them, and they need to place a flag at the middle (L/2 km).
     * 
     * 1. One approach is for person A to run the entire track to determine its total length (L),
     *    and then run back to the middle point (L/2). This is similar to first calculating the size 
     *    of a singly linked list and then traversing to the middle.
     * 
     * 2. A more efficient approach is for person A to get help from another person B, 
     *    who moves twice as fast (2X jumps/hour). Both start at the same point on the track:
     *    - Person B will run faster, and when they can no longer move forward (track exhausted),
     *      they inform person A. At this moment, person A will be exactly at the middle of the track.
     * 
     * - This works because for every jump person A takes, person B takes two jumps, 
     *   ensuring that person A's position is always half of person B's distance on the track.
     * - This eliminates the need for calculating the track length first, making the approach more efficient.
     * 
     * Additional Notes:
     * - For an **odd-sized list** (e.g., `1 -> 2 -> 3`), the loop ends when `fast.next == null`, 
     *   ensuring that `slow` is at the exact middle node (`2`).
     * - For an **even-sized list** (e.g., `1 -> 2 -> 3 -> 4`), the loop ends when `fast == null`, 
     *   ensuring that `slow` points to the second middle node (`3`).
     * - **As per the problem's requirement**, for even-sized lists, there are two middle nodes, 
     *   and we are expected to treat the second middle node as the middle.
     * - The condition `fast != null` ensures proper handling for even-sized lists, 
     *   while `fast.next != null` handles odd-sized lists.
     */
    public ListNode middleNode(ListNode head) {
        ListNode slow = head; // Moves one step at a time
        ListNode fast = head; // Moves two steps at a time

        // Fast pointer reaches the end, and slow pointer reaches the middle
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        // Slow pointer points to the middle node
        return slow;
    }
}
