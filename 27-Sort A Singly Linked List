/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

 //Bruteforce approach

class Solution {
    public ListNode sortList(ListNode head) {
        // Base case: empty or single node
        if (head == null || head.next == null) {
            return head;
        }

        //Collect node values
        List<Integer> nodeValues = collectNodeValues(head);

        // Sort values
        Collections.sort(nodeValues);

        //Reassign sorted values back to nodes
        ListNode node = head;
        for (int nodeValue : nodeValues) {
            node.val = nodeValue;
            node = node.next;
        }

        return head;
    }

    private List<Integer> collectNodeValues(ListNode head) {
        List<Integer> nodeValues = new ArrayList<>();
        ListNode node = head;

        //Traverses the linked list and collects node values.
        while (node != null) {
            nodeValues.add(node.val);
            node = node.next;
        }

        return nodeValues;
    }
}


//Optimal approach

class Solution {
    /**
    * Why Merge Sort for Linked List?
    * ------------------------------------------------------------
    *
    * Linked Lists do NOT support random access (no indexing).
    * Accessing the i-th element requires O(i) traversal.
    *
    * Because of this, many array-based sorting algorithms
    * become inefficient for linked lists.
    *
    *
    * ❌ Why NOT Quick Sort?
    * ------------------------------------------------------------
    * - Quick sort requires efficient partitioning.
    * - Partitioning depends heavily on random access.
    * - In linked lists, finding pivot position and swapping elements
    *   is expensive (requires traversal).
    * - Worst-case time complexity can degrade to O(n²).
    *
    * Therefore, quick sort is not ideal for linked lists.
    *
    *
    * ❌ Why NOT Heap Sort?
    * ------------------------------------------------------------
    * - Heap sort requires index-based access to maintain heap structure.
    * - Linked lists do not allow O(1) access to parent/child indices.
    * - Building and maintaining heap becomes inefficient.
    *
    *
    * ❌ Why NOT Selection Sort / Bubble Sort?
    * ------------------------------------------------------------
    * - These require repeated traversal to find min/max.
    * - Time complexity O(n²).
    * - Inefficient for large lists.
    *
    *
    * ⚠️ What About Insertion Sort?
    * ------------------------------------------------------------
    * - Insertion sort works well for linked lists.
    * - Because insertion in linked list is O(1) once position is found.
    * - But finding insertion position still costs O(n).
    * - Overall time complexity remains O(n²).
    *
    * It is suitable only for small lists.
    *
    *
    * ✅ Why Merge Sort Is Ideal?
    * ------------------------------------------------------------
    * - Does NOT require random access.
    * - Splitting list can be done using slow-fast pointer.
    * - Merging two sorted lists can be done in O(n).
    * - Guaranteed O(n log n) time complexity.
    * - Very natural fit for linked list structure.
    *
    */
    public ListNode sortList(ListNode head) {
        // Base case: empty list or single node is already sorted
        if (head == null || head.next == null) {
            return head;
        }
        /*
         * Recursively divide the list into two halves,
         * sorts them, and merges the sorted halves.
         */
        return mergeSort(head);
    }

    private ListNode mergeSort(ListNode head) {
        // Base case: single node is already sorted
        if (head.next == null) {
            return head;
        }

        //Find middle and split list
        ListNode firstHalfTail = findMiddle(head);
        ListNode secondHalfHead = firstHalfTail.next;

        //Break the list into two halves
        firstHalfTail.next = null;

        //Recursively sort both halves
        ListNode sortedFirstHalf = mergeSort(head);
        ListNode sortedSecondHalf = mergeSort(secondHalfHead);

        //Merge sorted halves
        return merge(sortedFirstHalf, sortedSecondHalf);
    }

    /**
     * IMPORTANT SUBTLE POINT:
     * -----------------------------------------------------------
     * For EVEN length lists, this function intentionally returns
     * the FIRST middle node (not the traditional second middle).
     *
     * Why is this necessary?
     *
     * Consider a list of length 2:
     *      1 → 2
     *
     * If we return the SECOND middle (node 2):
     *      first half  = 1 → 2
     *      second half = null
     *
     * After splitting, the first half remains unchanged.
     * The recursive call would again receive the same list (1 → 2),
     * resulting in no reduction of problem size.
     *
     * This leads to:
     *      Infinite recursion
     *      → StackOverflowError
     *
     * Instead, by returning the FIRST middle:
     *      first half  = 1
     *      second half = 2
     *
     * The list is properly divided into two smaller parts.
     * Each recursive call operates on a strictly smaller sublist,
     * guaranteeing termination of the recursion.
     */
    private ListNode findMiddle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        ListNode slowPrev = null;

        while (fast != null && fast.next != null) {
            slowPrev = slow;
            slow = slow.next;
            fast = fast.next.next;
        }

        // EVEN length case
        if (fast == null) {
            return slowPrev; // return first middle
        }

        // ODD length case
        return slow; // return exact middle
    }

    //Merges two sorted singly linked lists.
    private ListNode merge(ListNode head1, ListNode head2) {
        ListNode mergedHead = new ListNode(-1);
        ListNode mergedTail = mergedHead;

        ListNode node1 = head1;
        ListNode node2 = head2;

        while (node1 != null && node2 != null) {
            if (node1.val <= node2.val) {
                mergedTail.next = node1;
                ListNode next = node1.next;
                node1.next = null;
                node1 = next;
            } else {
                mergedTail.next = node2;
                ListNode next = node2.next;
                node2.next = null;
                node2 = next;
            }

            mergedTail = mergedTail.next;
        }

        if (node1 != null) {
            mergedTail.next = node1;
        }

        if (node2 != null) {
            mergedTail.next = node2;
        }

        return mergedHead.next;
    }
}
