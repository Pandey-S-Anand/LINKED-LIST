//Bruteforce Approach

/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

class Solution {
    /**
     * Idea:
     * - A stack follows LIFO (Last-In-First-Out).
     * - If we push all nodes into a stack,
     *   popping them will naturally give us nodes in reverse order.
     *
     * Steps:
     * 1) Traverse the original list and push each node onto a stack.
     *    - While pushing, detach node.next = null
     *      to prevent accidental cycles when rebuilding.
     *
     * 2) Pop nodes one by one:
     *    - First popped node becomes the new head.
     *    - Each subsequent popped node is linked using prev.next.
     *
     * Example:
     * Input:  1 -> 2 -> 3 -> 4
     *
     * Stack (top at left): 4, 3, 2, 1
     *
     * Rebuilt List:
     * 4 -> 3 -> 2 -> 1
     */
    public ListNode reverseList(ListNode head) {
        /**
        * Edge Case Handling:
        *
        * 1) If the list is empty (head == null):
        *    - There is nothing to reverse.
        *    - Simply return null.
        *
        * 2) If the list contains only one node (head.next == null):
        *    - A single-node list is already reversed by definition.
        *    - No pointer manipulation is required.
        */
        if (head == null || head.next == null) {
            return head;
        }

        Deque<ListNode> stack = collectNodesInReverseOrder(head);

        ListNode prev = null;

        // Pop nodes to reconstruct reversed list
        while (!stack.isEmpty()) {
            ListNode node = stack.pop();

            if (prev == null) {
                // First popped node becomes new head
                head = node;
            } else {
                prev.next = node;
            }

            prev = node;
        }

        return head;
    }

    private Deque<ListNode> collectNodesInReverseOrder(ListNode head) {
        Deque<ListNode> stack = new ArrayDeque<>();
        ListNode node = head;

        while (node != null) {
            stack.push(node);

            // Store next reference before breaking link
            ListNode next = node.next;
            node.next = null; //Break old linkage
            node = next;
        }

        return stack;
    }
}


//Optimal Approach

class Solution {
    /*
    * The core idea is to reverse the direction of the links between nodes.
    * Instead of using any additional data structures, we will:
    * 
    * - Maintain two pointers:
    *     1. node: to traverse the list.
    *     2. prev: to reverse the links and keep track of the new list.
    * 
    * - For each node, we:
    *     1. Save the next node ('node.next') to avoid losing track of the list.
    *     2. Set 'node.next' to 'prev', effectively reversing the direction of the link.
    *     3. Move 'prev' to 'node', and currentNode to the next node.
    * 
    * - Repeat this process for every node in the list until we reach the end.
    * 
    * - Once the loop completes, 'prev' will point to the new head of the reversed list.
    * 
    * This approach modifies the list in-place with no additional space required.
    */
    public ListNode reverseList(ListNode head) {
        // Edge case: empty list or single node list
        if (head == null || head.next == null) {
            return head;
        }

        ListNode prev = null;   // Will eventually become the new head
        ListNode node = head;   // Current node used for traversal

        // Traverse the entire list
        while (node != null) {
            // Store next node before breaking the link
            ListNode next = node.next;

            // Reverse the current node's pointer
            node.next = prev;

            // Move prev forward (prev becomes current node)
            prev = node;

            // Move traversal pointer forward
            node = next;
        }

        // After loop ends, prev points to the new head
        return prev;
    }
}



// Recursive Approach

class Solution {
    public ListNode reverseList(ListNode head) {
        // Edge case: empty list or single node list
        if (head == null || head.next == null) {
            return head;
        }

        return reverseList(head, null);
    }

    private ListNode reverseList(ListNode node, ListNode prev) {
        // Base case: when we reach end of list prev will be the new head
        if (node == null) {
            return prev;
        }

        // Save next node before breaking link
        ListNode next = node.next;

        // Reverse pointer
        node.next = prev;

        // Move pointers forward for next recursive call
        return reverseList(next, node);
    }
}
