//Bruteforce Approach

/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

class Solution {
    public boolean isPalindrome(ListNode head) {
        // Collect all node values into an ArrayList.
        List<Integer> nodeData = getNodeData(head);

        int low = 0;
        int high = nodeData.size() - 1;

        // Compare from both ends
        while (low < high) {
            if (!nodeData.get(low).equals(nodeData.get(high))) {
                return false;
            }

            low++;
            high--;
        }

        return true;
    }

    private List<Integer> getNodeData(ListNode head) {
        List<Integer> nodeData = new ArrayList<>();

        ListNode node = head;

        while (node != null) {
            nodeData.add(node.val);
            node = node.next;
        }

        return nodeData;
    }
}


//Optimal Approach

class Solution {
    public boolean isPalindrome(ListNode head) {
        // A single node is always a palindrome
        if (head.next == null) {
            return true;
        }

        //Find the tail of the first half
        ListNode firstHalfTail = getFirstHalfTail(head);

        //Split the list into two halves
        ListNode middle = firstHalfTail.next;
        firstHalfTail.next = null;

        //Reverse the second half
        ListNode tail = reverse(middle);

        ListNode node1 = head; // Traverses first half
        ListNode node2 = tail; // Traverses reversed second half

        /**
         * Why do we check only (node1 != null)?
         *
         * Case 1: Even length
         *   Both halves are equal in size.
         *
         *   Example:
         *   1 -> 2 -> 2 -> 1
         *
         *   firstHalfTail = first 2
         *   middle        = second 2
         *   First half    => 1 -> 2
         *   Second half   => 2 -> 1 (reversed → 1 -> 2)
         *
         * Case 2: Odd length
         *   The second half contains one extra element (the middle node).
         *
         *   Example:
         *   1 -> 2 -> 3 -> 2 -> 1
         *
         *   firstHalfTail = 2
         *   middle        = 3
         *   First half    => 1 -> 2
         *   Second half   => 3 -> 2 -> 1 (reversed → 1 -> 2 -> 3)
         *
         * The middle element does NOT affect the palindrome property.
         * If the elements on the left and right sides match,
         * the center element is irrelevant.
         *
         * Therefore:
         * - node1 will never overrun node2.
         * - Iterating until node1 becomes null is sufficient and safe.
         */
        while (node1 != null) {
            if (node1.val != node2.val) {
                return false;
            }

            node1 = node1.next;
            node2 = node2.next;
        }

        return true;
    }

    /**
     * Returns the tail node of the first half.
     *
     * For odd length:
     *   slow stops at the exact middle,
     *   so slowPrev becomes the node before middle.
     *
     * For even length:
     *   slow stops at the second middle,
     *   so slowPrev becomes the first middle.
     */
    private ListNode getFirstHalfTail(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        ListNode slowPrev = null;

        while (fast != null && fast.next != null) {
            slowPrev = slow;
            slow = slow.next;
            fast = fast.next.next;
        }

        return slowPrev;
    }

    private ListNode reverse(ListNode head) {
        ListNode prev = head;
        ListNode node = head.next;

        while (node != null) {
            ListNode next = node.next;
            node.next = prev;
            prev = node;
            node = next;
        }

        return prev;
    }
}
