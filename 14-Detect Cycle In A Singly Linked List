//Bruteforce Approach

public class Solution {
    /**    
     * Approach:
     * - Traverse the linked list from head.
     * - Store each visited node reference inside a HashSet.
     * - Before moving to the next node, check:
     *     If the current node already exists in the set,
     *     it means we have revisited a node → cycle detected.
     *
     * Why this works:
     * - In a normal (acyclic) linked list, each node is visited only once.
     * - In a cyclic list, traversal will eventually revisit
     *   a previously seen node reference.
     *
     * Important:
     * - We store node references, NOT node values.
     * - Two nodes may have the same value, but cycle detection
     *   must be based on memory reference.
     */
    public boolean hasCycle(ListNode head) {
        // Edge case: empty list or single node without self-loop
        if (head == null || head.next == null) {
            return false;
        }

        Set<ListNode> seenNodes = new HashSet<>(); // Tracks visited node references
        ListNode node = head;

        while (node != null) {
            // If we have already seen this node, cycle exists
            if (seenNodes.contains(node)) {
                return true;
            }

            // Mark current node as visited
            seenNodes.add(node);

            // Move to next node
            node = node.next;
        }

        // If traversal ends (node becomes null), no cycle exists
        return false;
    }
}


// Optimal Approach (Floyd's Cycle Detection Algorithm)

/**
 * Detects if a singly linked list contains a cycle.
 *
 * Approach:
 * - Uses Floyd's Cycle Detection Algorithm (Tortoise and Hare).
 * - Two pointers traverse the list:
 *     slow → moves one step at a time.
 *     fast → moves two steps at a time.
 *
 * - If a cycle exists:
 *     fast and slow will eventually meet inside the cycle.
 *
 * - If no cycle exists:
 *     fast or fast.next will become null,
 *     and the loop terminates safely.
 *
 * Important:
 * - The meeting point of slow and fast is NOT necessarily
 *   the starting node of the cycle.
 * - It only confirms that a cycle exists.
 *
 * Why do they meet?
 * - Inside a cycle, the fast pointer gains one extra step
 *   over the slow pointer in every iteration.
 * - This gradually reduces the gap between them.
 * - Eventually, fast catches up to slow.
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;

        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;

            if (fast == slow) {
                return true;
            }
        }

        return false;
    }
}
