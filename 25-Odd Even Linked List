/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

//Bruteforce approach

class Solution {
    /**
     * Rearranges a singly linked list such that:
     * - All nodes at odd positions come first
     * - Followed by all nodes at even positions
     *
     * NOTE:
     * This approach does NOT rearrange node pointers.
     * Instead, it rearranges node values.
     *
     * -------------------------------------------------------------
     * Approach:
     *
     * 1) Traverse the linked list once and collect values:
     *      - Values at odd positions → oddPositionValues
     *      - Values at even positions → evenPositionValues
     *
     * 2) Traverse the list again and:
     *      - First overwrite node values using oddPositionValues
     *      - Then overwrite remaining nodes using evenPositionValues
     *
     * 3) Return the modified head.
     *
     */
    public ListNode oddEvenList(ListNode head) {
        // Base case: empty list or single node → already arranged
        if (head == null || head.next == null) {
            return head;
        }

        List<Integer> oddPositionValues = new ArrayList<>();
        List<Integer> evenPositionValues = new ArrayList<>();

        ListNode node = head;
        boolean isOddIndex = true;

        // Collect values based on position
        while (node != null) {
            if (isOddIndex) {
                oddPositionValues.add(node.val);
            } else {
                evenPositionValues.add(node.val);
            }

            isOddIndex = !isOddIndex;
            node = node.next;
        }

        // Reassign values back to the list
        node = head;

        for (int oddPositionValue : oddPositionValues) {
            node.val = oddPositionValue;
            node = node.next;
        }

        for (int evenPositionValue : evenPositionValues) {
            node.val = evenPositionValue;
            node = node.next;
        }

        return head;
    }
}


//Optimal Approach

class Solution {
    /**
     * Rearranges a singly linked list such that:
     * - All nodes at odd positions appear first
     * - Followed by all nodes at even positions
     *
     * Positioning is based on 1-based indexing.
     * (i.e., head is considered position 1 → odd position)
     *
     * Example:
     * Input:  1 → 2 → 3 → 4 → 5
     * Output: 1 → 3 → 5 → 2 → 4
     *
     *
     * Approach:
     * ---------------------------------------------------------
     * 1) Create two separate lists:
     *      - One for odd-positioned nodes
     *      - One for even-positioned nodes
     *
     * 2) Traverse the original list once.
     *      - Use a boolean flag (isOddPosition) to track position.
     *      - Append current node to corresponding list.
     *
     * 3) While appending:
     *      - Save next reference.
     *      - Break original link (node.next = null)
     *        to avoid unintended cycles.
     *
     * 4) Finally:
     *      - Connect odd list tail to even list head.
     *
     *
     * Why Dummy Nodes?
     * ---------------------------------------------------------
     * Dummy nodes simplify list construction by:
     * - Avoiding special handling for first insertion.
     * - Maintaining clean tail pointers for O(1) append.
     */
    public ListNode oddEvenList(ListNode head) {
        // Edge case: 0 or 1 node → already arranged
        if (head == null || head.next == null) {
            return head;
        }

        // Dummy heads to simplify construction
        ListNode mergedOddHead = new ListNode(-1);
        ListNode mergedOddTail = mergedOddHead;

        ListNode mergedEvenHead = new ListNode(-1);
        ListNode mergedEvenTail = mergedEvenHead;

        ListNode node = head;
        boolean isOddPosition = true;

        // Traverse original list
        while (node != null) {
            if (isOddPosition) {
                // Append to odd list
                mergedOddTail.next = node;
                mergedOddTail = mergedOddTail.next;
            } else {
                // Append to even list
                mergedEvenTail.next = node;
                mergedEvenTail = mergedEvenTail.next;
            }

            // Save next node before detaching
            ListNode next = node.next;
            // Break original linkage to prevent cycle
            node.next = null;

            node = next;

            // Flip position flag
            isOddPosition = !isOddPosition;
        }

        // Attach even list after odd list
        mergedOddTail.next = mergedEvenHead.next;

        // Return head of rearranged list (skip dummy)
        return mergedOddHead.next;
    }
}
