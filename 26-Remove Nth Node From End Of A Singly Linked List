//Intuitive Approach

class Solution {
    /**
     * Approach :
     *
     * 1) First pass:
     *      - Compute the total length of the linked list.
     *
     * 2) Convert "Nth from end" into "index from start":
     *      target index from start (0-based) = length - n
     *
     * 3) Special Case:
     *      - If targetIdx == 0, the node to remove is the head.
     *      - Return head.next.
     *
     * 4) Otherwise:
     *      - Find the node just before the target node.
     *      - Re-link pointers to remove the target node.
     */
    public ListNode removeNthFromEnd(ListNode head, int n) {
        //Compute length of list
        int length = getLength(head);

        // Determine index of node to remove (0-based)
        int targetIdx = length - n;

        // If removing the head node
        if (targetIdx == 0) {
            return head.next;
        }

        // Find node before target
        ListNode node = getNodeAtIndex(head, targetIdx - 1);

        // Remove target node
        ListNode target = node.next;
        node.next = target.next;
        target.next = null; // Help GC (optional cleanup)

        return head;
    }

    private int getLength(ListNode head) {
        int length = 0;
        ListNode node = head;

        while (node != null) {
            length++;
            node = node.next;
        }

        return length;
    }

    private ListNode getNodeAtIndex(ListNode head, int index) {
        ListNode node = head;

        while (index > 0) {
            node = node.next;
            index--;
        }

        return node;
    }
}


//Optimal approach

/**
 * Remove the N-th node from the end of the list.
 *
 * Understanding the Logic (No Magic â€” Just Distance Math)
 * --------------------------------------------------------
 *
 * Suppose total length of the list = L.
 *
 * The N-th node from the end corresponds to:
 *
 *      Target index from start (0-based) = L - n
 *
 * To remove that node, we need to reach:
 *
 *      (L - n - 1)
 *
 * which is the index of the node just before the target.
 *
 *
 * What the Fast Pointer Does ?
 * --------------------------------------------------------
 * We first move the fast pointer `n` steps ahead of the slow pointer.
 *
 * After this:
 *
 *      distance(fast, slow) = n
 *
 * This gap remains constant because both pointers
 * move one step at a time afterward.
 *
 *
 * Key Observation
 * --------------------------------------------------------
 * When the fast pointer reaches the last node:
 *
 *      fast is at index (L - 1)
 *
 * Since the gap between fast and slow is always `n`,
 *
 *      slow must be at index (L - 1 - n)
 *
 * Which simplifies to:
 *
 *      (L - n - 1)
 *
 * That is exactly the node just before the target node.
 *
 *
 * Conclusion:
 * --------------------------------------------------------
 * Advancing fast by `n` steps creates a fixed window of size `n`.
 * When fast reaches the end, slow automatically lands
 * at the correct position to remove the target node.
 *
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // Initialize two pointers, fast and slow, both starting from the head
        ListNode fast = head;
        ListNode slow = head;

        // Move the fast pointer n steps ahead
        for (int i = 1; i <= n; i++) {
            fast = fast.next;
        }

        // If fast is null after moving n steps, it means we need to remove the head node
        if (fast == null) {
            return head.next; // Remove the first node (head)
        }

        // Move both pointers until fast reaches the end of the singly linked list
        while (fast.next != null) {
            fast = fast.next;
            slow = slow.next;
        }

        // Remove the nth node from the end
        ListNode target = slow.next;
        slow.next = target.next;
        target.next = null;

        return head; // Return the modified singly linked list
    }
}
